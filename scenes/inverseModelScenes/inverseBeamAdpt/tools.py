# -*- coding: utf-8 -*-
"""
Created on Jan 28 2020

@author: PSC
"""



import Sofa
import math
from math import sin, cos, pi
import os
import numpy as np
from collections import defaultdict


class Quat(np.ndarray):
    """ The Quat class implements the following:
    Public methods:
    q = Quat() # several constructors are implemented
    q.rotateFromQuat(q1)
    q.rotateFromEuler(v)
    q.normalize()
    q.flip()
    q.getIm()
    q.getRe()
    q.getNorm()
    q.getInverse()
    q.getConjugate()
    q.getMatrix()
    q.getEulerAngles()
    q.getAxisAngle()
    q.toString()
    Static methods:
    q = Quat.product(q1,q2)
    q = Quat.createFromEuler([x,y,z])
    q = Quat.createFromAxisAngle([axis],angle)
    """

    def __new__(cls, *args):
        """ Quat constructor expects zero, one, or four arguments. Quat has the Sofa format i.e (x,y,z,w).
        Examples:
        >>> q = Quat()
        >>> print(q)
        [0.,0.,0.,1.]
        >>> q = Quat(0.,0.,0.,1.)
        >>> print(q)
        [0.,0.,0.,1.]
        >>> q = Quat([0.,0.,0.,1.])
        >>> print(q)
        [0.,0.,0.,1.]
        """
        if len(args)==0:
            return super(Quat,cls).__new__(cls, shape=(4,), dtype=float, buffer=np.array([0.,0.,0.,1.]))
        elif hasattr(args[0],"__len__") and len(args[0])==4:
            return super(Quat,cls).__new__(cls, shape=(4,), dtype=type(args[0][0]), buffer=np.array([args[0][0],args[0][1],args[0][2],args[0][3]]))
        elif len(args)==4:
            return super(Quat,cls).__new__(cls, shape=(4,), dtype=type(args[0]), buffer=np.array([args[0],args[1],args[2],args[3]]))

        print(cls.__new__.__doc__)
        return super(Quat,cls).__new__(cls, shape=(4,), dtype=float, buffer=np.array([0.,0.,0.,1.]))


    def __eq__(self, other):
        """ Quat overriding of __eq__ so that (q1==q2) returns a boolean.
        """
        results = (super(Quat,self).__eq__(other))
        for result in results:
            if result == False:
                return False
        return True


    def __ne__(self, other):
        """ Quat overriding of __ne__ so that (q1!=q2) returns a boolean.
        """
        return not (self == other)


    def normalize(self, *args):
        """ Function normalize of class Quat normalize the vector. The function expects no argument.
        """
        self /= self.getNorm()


    def rotateFromQuat(self, qb):
        """Function rotateFromQuat of class Quat rotates the current Quat from the given one.
        Examples:
        >>> q1 = Quat.createFromAxisAngle([1., 0., 0.], pi/2.)
        >>> q2 = Quat.createFromAxisAngle([0., -1., 0.], pi/2.)
        >>> q1.rotateFromQuat(q2)
        >>> print(q1)
        [ 0.5 -0.5 -0.5  0.5]
        """

        self.put(range(4),self.product(self,qb))


    def rotateFromEuler(self, v, axes="sxyz"):
        """Function rotateFromEuler of class Quat combine the current Quat from euler angles.
        Examples:
        >>> q = Quat.createFromAxisAngle([1., 0., 0.], pi/2.)
        >>> q.rotateFromEuler([0.,-pi/2.,0.])
        >>> print(q)
        [ 0.5 -0.5 -0.5  0.5]
        """

        q = Quat.createFromEuler(v)
        self.put(range(4),self.product(self,q))


    def flip(self):
        """Function flip of class Quat flips the quaternion to the real positive hemisphere if needed.
        """
        if self.getRe() < 0:
            self.put(range(4),-1*self)



    def getNorm(self):
        """ Returns the norm of the quaternion.
        """
        return np.linalg.norm(self)


    def getRe(self):
        """Returns the real part of the quaternion.
        Example:
        >>> q = Quat(0.65,0.,0.,0.75)
        >>> q.getRe()
        0.75
        """
        return float(self.take(3))


    def getIm(self):
        """Returns the imaginary part of the quaternion.
        Example:
        >>> q = Quat(0.65,0.,0.,0.75)
        >>> q.getIm()
        [0.65,0.,0.]
        """
        return np.array(self.take(range(3)))


    def getAxisAngle(self):
        """ Returns rotation vector corresponding to unit quaternion in the form of [axis, angle]
        """
        import sys
        q = Quat(self)
        q.flip()  # flip q first to ensure that angle is in the [-0, pi] range

        angle = 2.0* math.acos(q.getRe())

        if angle > sys.float_info.epsilon:
            return [ q.getIm() / math.sin(angle/2.), angle ]

        norm = np.linalg.norm(q.getIm())
        if norm > sys.float_info.epsilon:
            sign = 1.0 if angle > 0 else -1.0
            return [ q.getIm() * (sign / norm), angle ]

        return [ np.zeros(3), angle ]

    def getEulerAngles(self, axes='sxyz'):
        """Returns the Euler angles in radian for specified axis sequence.
        """

        M = self.getMatrix()

        try:
            firstaxis, parity, repetition, frame = AXES_TO_TUPLE[axes.lower()]
        except (AttributeError, KeyError):
            TUPLE_TO_AXES[axes]  # validation
            firstaxis, parity, repetition, frame = axes

        i = firstaxis
        j = NEXT_AXIS[i+parity]
        k = NEXT_AXIS[i-parity+1]

        a = np.empty((3, ))

        if repetition:
            sy = math.sqrt(M[i, j]*M[i, j] + M[i, k]*M[i, k])
            if sy > EPS:
                a[0] = math.atan2( M[i, j],  M[i, k])
                a[1] = math.atan2( sy,       M[i, i])
                a[2] = math.atan2( M[j, i], -M[k, i])
            else:
                a[0] = math.atan2(-M[j, k],  M[j, j])
                a[1] = math.atan2( sy,       M[i, i])
                a[2] = 0.0
        else:
            cy = math.sqrt(M[i, i]*M[i, i] + M[j, i]*M[j, i])
            if cy > EPS:
                a[0] = math.atan2( M[k, j],  M[k, k])
                a[1] = math.atan2(-M[k, i],  cy)
                a[2] = math.atan2( M[j, i],  M[i, i])
            else:
                a[0] = math.atan2(-M[j, k],  M[j, j])
                a[1] = math.atan2(-M[k, i],  cy)
                a[2] = 0.0

        if parity:
            a[0], a[1], a[2] = -a[0], -a[1], -a[2]
        if frame:
            a[0], a[2] = a[2], a[0]
        return a


    def getMatrix(self):
        """Returns the convertion of the quaternion into rotation matrix form.
        """
        q = Quat(self)

        # Repetitive calculations
        q44 = q[3]**2
        q12 = q[0] * q[1]
        q13 = q[0] * q[2]
        q14 = q[0] * q[3]
        q23 = q[1] * q[2]
        q24 = q[1] * q[3]
        q34 = q[2] * q[3]

        matrix = np.empty((3,3))

        # The diagonal
        matrix[0, 0] = 2.0 * (q[0]**2 + q44) - 1.0
        matrix[1, 1] = 2.0 * (q[1]**2 + q44) - 1.0
        matrix[2, 2] = 2.0 * (q[2]**2 + q44) - 1.0

        # Off-diagonal
        matrix[0, 1] = 2.0 * (q12 - q34)
        matrix[0, 2] = 2.0 * (q13 + q24)
        matrix[1, 2] = 2.0 * (q23 - q14)

        matrix[1, 0] = 2.0 * (q12 + q34)
        matrix[2, 0] = 2.0 * (q13 - q24)
        matrix[2, 1] = 2.0 * (q23 + q14)

        return matrix


    def getConjugate(self):
        """Returns the conjugate of the quaternion.
        Example:
        >>> q = Quat(0.707,0.,0.,0.707)
        >>> q.getConjugate()
        [-0.707,0.,0.,0.707]
        """
        return Quat(-self.take(0),-self.take(1),-self.take(2),self.take(3))


    def getInverse(self):
        """Returns the inverse of the quaternion.
        If you are dealing with unit quaternions, use getConjugate() instead.
        """
        return  self.getConjugate() / self.getNorm()**2


    def toString(self):
        """Returns the quaternion in string format.
        """
        return  str(self.take(0))+" "+str(self.take(1))+" "+str(self.take(2))+" "+str(self.take(3))


    @staticmethod
    def createFromAxisAngle(axis, angle):
        """ Function createQuatFromAxis from quat expects two arguments. Quat has the Sofa format i.e (x,y,z,w).
        Examples:
        >>> q = Quat.createQuatFromAxis([1.,0.,0.],pi/2.)
        >>> print(q)
        [0.707,0.,0.,0.707]
        Note that the angle should be in radian.
        """
        from quat import Quat
        q = Quat()
        q[0]=axis[0]*math.sin(angle/2.)
        q[1]=axis[1]*math.sin(angle/2.)
        q[2]=axis[2]*math.sin(angle/2.)
        q[3]=math.cos(angle/2.)

        q.normalize()
        return q


    @staticmethod
    def createFromEuler(a, axes='sxyz', inDegree=False):
        """Returns a quaternion from Euler angles (in radian) and axis sequence.
        The quaternion is of type Quat.
        Args:
        a is a list of three Euler angles [x,y,z]
        axes : One of 24 axis sequences as string or encoded tuple
        Example:
        >>> q = Quat.createFromEuler([-pi, 0., 0.], 'sxyz')
        >>> print(q)
        [ 1.0 0.0  0.0  0.0]
        >>> q = Quat.createFromEuler([-pi/2., pi/2., 0.], 'ryxz') #r stands for repetition
        >>> print(q)
        [ 0.5 -0.5  0.5  0.5]
        """

        if inDegree:
            a = [a[0]*pi/180, a[1]*pi/180, a[2]*pi/180]

        try:
            firstaxis, parity, repetition, frame = AXES_TO_TUPLE[axes.lower()]
        except (AttributeError, KeyError):
            TUPLE_TO_AXES[axes]  # validation
            firstaxis, parity, repetition, frame = axes

        i = firstaxis
        j = NEXT_AXIS[i+parity]
        k = NEXT_AXIS[i-parity+1]

        if frame:
            a[0], a[2] = a[2], a[0]
        if parity:
            a[1] = -a[1]

        a[0] /= 2.0
        a[1] /= 2.0
        a[2] /= 2.0
        ci = math.cos(a[0])
        si = math.sin(a[0])
        cj = math.cos(a[1])
        sj = math.sin(a[1])
        ck = math.cos(a[2])
        sk = math.sin(a[2])
        cc = ci*ck
        cs = ci*sk
        sc = si*ck
        ss = si*sk

        q = Quat()
        if repetition:
            q[3] = cj*(cc - ss)
            q[i] = cj*(cs + sc)
            q[j] = sj*(cc + ss)
            q[k] = sj*(cs - sc)
        else:
            q[3] = cj*cc + sj*ss
            q[i] = cj*sc - sj*cs
            q[j] = cj*ss + sj*cc
            q[k] = cj*cs - sj*sc
        if parity:
            q[j] *= -1.0

        return q


    @staticmethod
    def product(qa, qb):
        """Use this product to compose the rotations represented by two quaterions.
        Example:
        >>> q1 = Quat()
        >>> q2 = Quat()
        >>> Quat.product(q1,q2)
        [0.,0.,0.,1.]
        """

        # Here is a readable version :
        # array([ qa[3]*qb[0] + qb[3]*qa[0] + qa[1]*qb[2] - qa[2]*qb[1],
        # qa[3]*qb[1] + qb[3]*qa[1] + qa[2]*qb[0] - qa[0]*qb[2],
        # qa[3]*qb[2] + qb[3]*qa[2] + qa[0]*qb[1] - qa[1]*qb[0],
        # qa[3]*qb[3] - qb[0]*qa[0] - qa[1]*qb[1] - qa[2]*qb[2] ])
        return Quat(np.hstack( (qa.getRe()*qb.getIm() + qb.getRe()*qa.getIm() + np.cross( qa.getIm(), qb.getIm() ), [qa.getRe() * qb.getRe() - np.dot( qa.getIm(), qb.getIm())] )))


##### adapted from http://www.lfd.uci.edu/~gohlke/code/transformations.py.html

# epsilon for testing whether a number is close to zero
EPS = np.finfo(float).eps * 4.0

# Axis sequences for Euler angles
NEXT_AXIS = [1, 2, 0, 1]

# Map axes strings to/from tuples of inner axis, parity, repetition, frame
AXES_TO_TUPLE = {
    'sxyz': (0, 0, 0, 0), 'sxyx': (0, 0, 1, 0), 'sxzy': (0, 1, 0, 0),
    'sxzx': (0, 1, 1, 0), 'syzx': (1, 0, 0, 0), 'syzy': (1, 0, 1, 0),
    'syxz': (1, 1, 0, 0), 'syxy': (1, 1, 1, 0), 'szxy': (2, 0, 0, 0),
    'szxz': (2, 0, 1, 0), 'szyx': (2, 1, 0, 0), 'szyz': (2, 1, 1, 0),
    'rzyx': (0, 0, 0, 1), 'rxyx': (0, 0, 1, 1), 'ryzx': (0, 1, 0, 1),
    'rxzx': (0, 1, 1, 1), 'rxzy': (1, 0, 0, 1), 'ryzy': (1, 0, 1, 1),
    'rzxy': (1, 1, 0, 1), 'ryxy': (1, 1, 1, 1), 'ryxz': (2, 0, 0, 1),
    'rzxz': (2, 0, 1, 1), 'rxyz': (2, 1, 0, 1), 'rzyz': (2, 1, 1, 1)}

TUPLE_TO_AXES = dict((v, k) for k, v in AXES_TO_TUPLE.items())


def createLinePoints(x_max, numLines):

    step = x_max/numLines;
    pos_out = [0]*3*(numLines+1)
    x_c=0;

    for i in range(numLines):
        x_c=x_c+step;
        pos_out[3*i+3]= x_c;

    return pos_out


def createLines( numLines):
    lines=[0]*2*numLines;


    for i in range(numLines):
        lines[2*i]=i
        lines[2*i+1]=i+1

    return lines


def transformTableInString(Table):
    sizeT =  len(Table);
    strOut= ' ';
    for p in range(sizeT):
        strOut = strOut+ str(Table[p])+' '


    return strOut


class Graph:
    def __init__(self):
        """
        self.edges is a dict of all possible next nodes
        e.g. {'X': ['A', 'B', 'C', 'E'], ...}
        self.weights has all the weights between two nodes,
        with the two nodes as a tuple as the key
        e.g. {('X', 'A'): 7, ('X', 'B'): 2, ...}
        """
        self.edges = defaultdict(list)
        self.weights = {}

    def add_edge(self, from_node, to_node, weight):
        # Note: assumes edges are bi-directional
        self.edges[from_node].append(to_node)
        self.edges[to_node].append(from_node)
        self.weights[(from_node, to_node)] = weight
        self.weights[(to_node, from_node)] = weight


def dijkstra(graph, initial, end):
    # shortest paths is a dict of nodes
    # whose value is a tuple of (previous node, weight)
    shortest_paths = {initial: (None, 0)}
    current_node = initial
    visited = set()

    while current_node != end:
        visited.add(current_node)
        destinations = graph.edges[current_node]
        weight_to_current_node = shortest_paths[current_node][1]

        for next_node in destinations:
            weight = graph.weights[(current_node, next_node)] + weight_to_current_node
            if next_node not in shortest_paths:
                shortest_paths[next_node] = (current_node, weight)
            else:
                current_shortest_weight = shortest_paths[next_node][1]
                if current_shortest_weight > weight:
                    shortest_paths[next_node] = (current_node, weight)

        next_destinations = {node: shortest_paths[node] for node in shortest_paths if node not in visited}
        if not next_destinations:
            return "Route Not Possible"
        # next node is the destination with the lowest weight
        current_node = min(next_destinations, key=lambda k: next_destinations[k][1])

    # Work back through destinations in shortest path
    path = []
    while current_node is not None:
        path.append(current_node)
        next_node = shortest_paths[current_node][0]
        current_node = next_node
    # Reverse path
    path = path[::-1]
    return path